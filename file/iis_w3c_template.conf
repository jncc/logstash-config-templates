input {
  file {
    path => "${FILE_LOG_PATH}"
    start_position => beginning
    sincedb_path => "${SINCEDB_PATH}"
    add_field => ["split_querystring", "${LOGSTASH_SPLIT_QUERYSTRING}"]
  }
}
filter {
  # Drop initial commented lines
  if ([message] =~ /^#/) {
    drop{}
  }
  
  grok {
    match => {
      "message" => "%{TIMESTAMP_ISO8601:timestamp} %{IP:host_ip} %{WORD:http_verb} %{NOTSPACE:request_path} %{NOTSPACE:request_querystring} %{NUMBER:port} (?:-|%{NOTSPACE:username}) %{IP:source_ip} %{NOTSPACE:user_agent} (?:-|%{NOTSPACE:referer}) %{NUMBER:http_status} %{NUMBER:sub_status} %{NUMBER:win32_status} %{NUMBER:response_time}"
    }
  }

  mutate {
    lowercase => "request_path"
    lowercase => "request_querystring"
    rename => {
      "host_ip" => "[server][ip]"
      "http_verb" => "[request][http][verb]"
      "http_status" => "[response][http][status]"
      "source_ip" => "[request][ip]"
      "referer" => "[request][referer]"
      "user_agent" => "[request][user_agent]"
      "request_path" => "[request][path]"
      "request_querystring" => "[request][querystring]"
      "sub_status" => "[iis][sub_status]"
      "win32_status" => "[iis][win32_status]"
      "response_time" => "[response][time]"
    }
  }

  geoip {
    source => "[request][ip]"
    target => "[request][geoip]"
    database => "/data/logstash/GeoLite2-City.mmdb"
    add_field => [ "[request][geoip][coordinates]", "%{[request][geoip][longitude]}" ]
    add_field => [ "[request][geoip][coordinates]", "%{[request][geoip][latitude]}" ]
  }

  mutate {
    convert => [
	  "[request][geoip][coordinates]", "float",
	  "[response][time]", "integer"
    ]
  }

  date {
    locale => "en"
    match => ["timestamp", "YYYY-MM-dd HH:mm:ss"]
  }
}

output {
  elasticsearch {
    hosts => ["${ELASTICSEARCH_CLUSTER_HOST}:${ELASTICSEARCH_CLUSTER_PORT}"]
    index => "${ELASTICSEARCH_INDEX_NAME}-%{+YYYY.MM}"
  }
  stdout {
    codec => rubydebug
  }
}
